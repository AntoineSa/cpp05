Notes webserv: 
-Il faut un tableau qui associe le fd a une reference const de connection

Map input_pipe_list (fd, connection)
Map output_pipe_list (fd, connection)

Fonction write_body_to_pipe(int fd, HttpRequest request)

Fonction read_and_parse_cgi_output(int fd, char **output)
 -il faut une fonction
 

Etapes:
1. La requête doit lancer un CGI
2. Je cree tous les pipes dans le launcher:
3. J’ajoute l’inputpipe écriture fd a la map inputpipe_list avec la connexion, puis j’ajoute le fd aux wfds de select
4. J’ajoute l’outputpipe lecture fd a la map output pipe list avec la connexion, puis j’ajoute le fd aux rfds de select

	—> pour faire cette étape, il faut que le cgi launcher ait 2 refs const sur int pour que je puisse recup les fds

1. Je fork, je close ce qui doit être close, je fais les dups nécessaires, je lance l’exec
2. Je set: connexion.hasToWriteOnPipe
3. Je quitte la fonction 
4. Je retourne au select
5. Si connexion attend écriture:

	—> si connexion.HasToWriteOnPipe : continue
	—> si connexion.HasToReadOnPipe : continue
	—> si connexion.HasDoneCgi: write answer



1. Si le wfd appartient a input_pipe_list:
	-> je write dans le fd le body
	->HasToWriteOnPipe=0
	-> j’enlève le fd de la liste;

2. Si le wfd appartient a output_pipe_list
	-> j’envoie un read:
		-si read = 0:
			->HasToReadOnPipe = 0;
			-> j’enleve le fd de la liste;
		-si read > 0: 
			-> j’appende la merde au body de la réponse;

Il faut mécanisme de transmission des infos de connexion et mécanisme de sauvegarde de la réponse

